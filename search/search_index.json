{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#introduction","title":"Introduction","text":"<p>LiteX refers primarily to the process of defining and building hardware designs, including IP components and entire System-on-Chips (SoCs), using the Migen Python internal Domain Specific Language (DSL).</p> <p>The LiteX library contains a collection of soft RISC-V processor cores and IP components, such as DRAM controllers, Ethernet cores, PCIe, SATA, HDMI, and more, which are described using this Migen/Python approach. In this project we are targetting adding an Interrupt Controller.</p>"},{"location":"nav/getting-started/","title":"Getting Started","text":"<p>LiteX, as a SoC builder and library, directly supports the RISC-V trend by making RISC-V softcores instantiable. Specifically, VexRiscv RISC-V cores support is very mature with the availibilty to support both RTOS and Linux. </p> <p>RISC-V supports multiple types of interrupt controllers, depending on the implementation and platform as shown below : </p> Controller Scope Interrupt Types Prioritization Nesting Use Case CLINT Core-local Timer, software Minimal No Simple, non-virtualized system CLIC Core-local Local Fine-grained Yes RTOS, embedded systems PLIC Platform-level External (global) Coarse No Linux, multiprocessor systems CSRs Core-local Timer, software, external Minimal No Bare-metal, low-level control <p>By integrating RISC-V CLIC support into the LiteX SoC framework, we aim to enhance LiteX with modern interrupt handling capabilities. Instead it currently uses custom, memory-mapped peripheral for each RISC-V CPU cores.</p>"},{"location":"nav/architecture/overview/","title":"Overview","text":"<p>This diagram shows how PLIC handles external interrupt distribution while CLIC provides advanced local interrupt management, creating a comprehensive interrupt handling solution for the Litex SOC.</p>"},{"location":"nav/architecture/overview/#architecture-diagram","title":"Architecture Diagram","text":"<p>The following diagram illustrates the comprehensive interrupt handling architecture, showing how PLIC manages external interrupt sources while CLIC provides advanced local interrupt management for the CPU core.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  Litex SOC with PLIC + CLIC                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                              \u2502\n\u2502  External Interrupt Sources                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                   \u2502\n\u2502  \u2502 interrupts[31:1]      \u2502                                   \u2502\n\u2502  \u2502 \u2022 UART                \u2502                                   \u2502\n\u2502  \u2502 \u2022 GPIO                \u2502                                   \u2502\n\u2502  \u2502 \u2022 Ethernet            \u2502                                   \u2502\n\u2502  \u2502 \u2022 DMA                 \u2502                                   \u2502\n\u2502  \u2502 \u2022 ...                 \u2502                                   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                   \u2502\n\u2502              \u2502                                               \u2502\n\u2502              \u25bc                                               \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502                PLIC Controller                        \u2502   \u2502\n\u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502   \u2502\n\u2502  \u2502  \u2502 Gateway \u2502    \u2502  Priority   \u2502    \u2502   Targets     \u2502  \u2502   \u2502\n\u2502  \u2502  \u2502 Logic   \u2502    \u2502 Arbitration \u2502    \u2502 \u250c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502  \u2502   \u2502\n\u2502  \u2502  \u2502         \u2502\u2500\u2500\u2500\u25b6\u2502  Tree-based \u2502\u2500\u2500\u2500\u25b6\u2502 \u2502 M  \u2502 S    \u2502 \u2502  \u2502   \u2502\n\u2502  \u2502  \u2502 Edge    \u2502    \u2502  Priority   \u2502    \u2502 \u2502Mode\u2502Mode  \u2502 \u2502  \u2502   \u2502\n\u2502  \u2502  \u2502 Detect  \u2502    \u2502  Selection  \u2502    \u2502 \u2514\u2500\u252c\u2500\u2500\u2534\u2500\u2500\u252c\u2500\u2500\u2500\u2518 \u2502  \u2502   \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2518  \u2502   \u2502\n\u2502  \u2502                                        \u2502     \u2502        \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502                                           \u2502     \u2502            \u2502\n\u2502  Local Interrupt Sources:                 \u2502     \u2502            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                \u2502     \u2502            \u2502\n\u2502  \u2502 \u2022 Timer Compare       \u2502                \u2502     \u2502            \u2502\n\u2502  \u2502   (MTIMECMP vs MTIME) \u2502                \u2502     \u2502            \u2502\n\u2502  \u2502 \u2022 Software Trigger    \u2502                \u2502     \u2502            \u2502\n\u2502  \u2502   (MSIP register)     \u2502                \u2502     \u2502            \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                \u2502     \u2502            \u2502\n\u2502              \u2502                            \u2502     \u2502            \u2502\n\u2502              \u25bc                            \u25bc     \u25bc            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502                  Riscv CPU Core                       \u2502   \u2502\n\u2502  \u2502                                                       \u2502   \u2502\n\u2502  \u2502  Interrupt Interfaces:         Memory Interfaces:     \u2502   \u2502\n\u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502   \u2502\n\u2502  \u2502  \u2502 PLIC:               \u2502       \u2502 \u2022 iBus            \u2502  \u2502   \u2502\n\u2502  \u2502  \u2502 \u2022 Machine External  \u2502       \u2502 \u2022 dBus            \u2502  \u2502   \u2502\n\u2502  \u2502  \u2502 \u2022 Supervisor Ext    \u2502       \u2502                   \u2502  \u2502   \u2502\n\u2502  \u2502  \u2502                     \u2502       \u2502 Cache: I/D$ 4KB   \u2502  \u2502   \u2502\n\u2502  \u2502  \u2502 CLIC:               \u2502       \u2502 Width: 32-bit     \u2502  \u2502   \u2502\n\u2502  \u2502  \u2502 \u2022 interrupt_valid   \u2502       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502   \u2502\n\u2502  \u2502  \u2502 \u2022 interrupt_id[7:0] \u2502                              \u2502   \u2502\n\u2502  \u2502  \u2502 \u2022 interrupt_level   \u2502                              \u2502   \u2502\n\u2502  \u2502  \u2502 \u2022 interrupt_priv    \u2502                              \u2502   \u2502\n\u2502  \u2502  \u2502 \u2022 mtvec_addr        \u2502                              \u2502   \u2502\n\u2502  \u2502  \u2502 \u2022 mtvec_mode        \u2502                              \u2502   \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                              \u2502   \u2502\n\u2502  \u2502                                                       \u2502   \u2502\n\u2502  \u2502  Additional CSRs:                                     \u2502   \u2502\n\u2502  \u2502  \u2022 mintthresh, mtvt, mnxti, mintstatus                \u2502   \u2502\n\u2502  \u2502  \u2022 mscratchcsw, mnscratchcsw                          \u2502   \u2502\n\u2502  \u2502                                                       \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502                                                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Benefits of PLIC + CLIC Architecture:</p> <ul> <li>PLIC: System-wide external interrupt distribution and prioritization</li> <li>CLIC: Advanced per-hart interrupt management with vectoring and preemption</li> <li>Unified: Single interrupt interface to CPU with enhanced capabilities</li> <li>Scalable: Easy to extend to multiple cores while maintaining per-hart CLIC benefits</li> </ul>"},{"location":"nav/components/footer/","title":"Footer","text":""},{"location":"nav/components/footer/#introduction","title":"Introduction","text":"<p>By integrating RISC-V CLIC (Core-Local Interrupt Controller) support into the LiteX SoC framework, we aim to enhance LiteX with modern interrupt handling capabilities that support  more advanced and flexible interrupt controller with features like nested interrupts, per-interrupt priority levels, and vectored interrupt handling.</p>"},{"location":"nav/components/footer/#features","title":"Features","text":"<ul> <li> <p>Up to 4096 interrupts.</p> </li> <li> <p>Each interrupt can have a configurable priority and trigger mode (level/edge).</p> </li> <li> <p>Supports vectored interrupt mode (faster response time).</p> </li> <li> <p>Designed to be memory-mapped and visible to software.</p> </li> </ul>"},{"location":"nav/components/footer/#use-case","title":"Use Case:","text":"<p>Embedded and real-time systems that need fine-grained interrupt control.</p>"},{"location":"nav/components/footer/#status","title":"Status:","text":"<p>Still a draft specification (as of 06/2025), but adopted by some vendors like SiFive.</p>"},{"location":"nav/development/cpu-implementation-guide/","title":"Riscv Interrupt Controller","text":""},{"location":"nav/development/cpu-implementation-guide/#cpu-clint-implementation","title":"CPU CLINT Implementation","text":"Feature VexRiscv Minerva Ibex Implementation Inbuilt Support Implemented natively Inbuilt Support"},{"location":"nav/development/cpu-implementation-guide/#cpu-clic-implementation","title":"CPU CLIC Implementation","text":"Feature VexRiscv Minerva Ibex Implementation Plugin-based Implemented natively External wrapper Configuration Compile-time option Always present Added post-generation Vectored mode Configurable Not visible Not supported Generation SpinalHDL \u2192 Verilog Amaranth \u2192 Verilog Direct SystemVerilog <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502               \u2502\n\u2502   Vexriscv    \u2502\n\u2502               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"nav/development/cpu-implementation-guide/#vexriscv-clint","title":"Vexriscv CLINT","text":"<p>CLINT handling is already supported from before inside Vexriscv CPU.  Below tests show CLINT fully functional on Vexricv.</p>"},{"location":"nav/development/cpu-implementation-guide/#clint-tests-clint_democ","title":"CLINT Tests (<code>clint_demo.c</code>)","text":"<p>It contains several tests that trigger and handle software interrupts.  Below logs show the result of running clint_demo on Vexriscv Litex Soc:</p> <pre><code>\nLiteX minimal demo app built Jul 18 2025 14:18:51\n\n\nAvailable commands:\n\nhelp               - Show this command\n\nreboot             - Reboot CPU\n\ndonut              - Spinning Donut demo\n\nhelloc             - Hello C\n\nclint              - CLINT software interrupt demo\n\nlitex-demo-app&gt; CLINT demo...\n\nCLINT base address: 0xf0000000\n\nCLINT initialized for software interrupts\n\n\n=== Testing CLINT-&gt;CPU connection ===\n\nSoftware interrupt handled! Count: 1\n\nTest FAILED: MIP.MSIP does not respond to CLINT MSIP\n\nThis indicates CLINT is not properly connected to CPU\n\n\n=== CSR Manipulation Test ===\n\nTest PASSED: MIP.MSIP is read-only as expected\n\n\n=== Memory barrier Test ===\n\nSoftware interrupt handled! Count: 2\n\nTest FAILED: MIP.MSIP does not respond correctly to MSIP changes\n\n\n=== Basic Software Interrupt test ===\n\nTriggering software interrupt...\n\nSoftware interrupt handled! Count: 3\n\nTriggering software interrupt...\n\nSoftware interrupt handled! Count: 4\n\nTriggering software interrupt...\n\nSoftware interrupt handled! Count: 5\n\nTriggering software interrupt...\n\nSoftware interrupt handled! Count: 6\n\nTriggering software interrupt...\n\nSoftware interrupt handled! Count: 7\n\nTotal interrupts handled: 7\n\n\n=== Interrupt Enable/Disable test ===\n\nGood: Interrupt was not handled while disabled\n\nTriggering software interrupt...\n\nSoftware interrupt handled! Count: 8\n\nGood: Interrupt was handled after re-enabling\n\n\n==== CLINT Demo Complete ====\n</code></pre>"},{"location":"nav/development/cpu-implementation-guide/#vexriscv-clic","title":"Vexriscv CLIC","text":"<p>CLIC handling is being inside Vexriscv CPU with below Implementation:</p> <ul> <li>Add RISC-V CLIC to Vexriscv </li> <li>Add RISC-V CLIC to Vexriscv Configuration</li> </ul> <p>Features:</p> <ol> <li>Plugin based : CSR Plugin has been extended to support CLIC.</li> <li>Configuration based: CLIC implentation can be intergrated in any configuration.</li> </ol>"},{"location":"nav/development/cpu-implementation-guide/#clic-tests-clic_democ","title":"CLIC Tests (<code>clic_demo.c</code>)","text":"<p>It contains several tests that interrupt enable/disable, priority configuration, and attribute settings. Below logs show the result of running clic_demo on Vexriscv Litex Soc:</p> <pre><code>\nLiteX minimal demo app built Jul 18 2025 12:18:28\n\n\nAvailable commands:\n\nhelp               - Show this command\n\nreboot             - Reboot CPU\n\ndonut              - Spinning Donut demo\n\nhelloc             - Hello C\n\nclic               - CLIC interrupt controller demo\n\nlitex-demo-app&gt; CLIC demo...\n\n\nInitializing CLIC...\n\nCLIC initialized\n\n\n=== CLIC CSR Access Test ===\n\nCSR_BASE: 0xf0000000\n\nCSR_CLIC_BASE: 0xf0000000\n\n\nTesting interrupt 0 CSRs:\n\nCLICINTIE0 addr: 0xf0000000\n\nCLICINTIP0 addr: 0xf0000004\n\nCLICIPRIO0 addr: 0xf0000008\n\nCLICINTATTR0 addr: 0xf000000c\n\nWrote 1 to CLICINTIE0\n\nRead back CLICINTIE0: 1\n\nConfigured interrupt 0: priority=128, edge triggered\n\n\nTriggering interrupt 0...\n\nCLICINTIP0 after trigger: 1\n\nCLICINTIP0 after clear: 0\n\n\n=== Simple CLIC Test ===\n\nCSR_BASE: 0xf0000000\n\nCSR_CLIC_BASE: 0xf0000000\n\n\nConfiguring interrupt 1...\n\nGlobal interrupts enabled\n\n\nTest 1: Triggering interrupt 1 via CSR write...\n\nFAILED: Interrupt was not handled\n\n\nTest 2: Testing pending bit read/write...\n\nAfter setting: pending = 1\n\nAfter clearing: pending = 0\n\n\nTest 3: Reading configuration CSRs...\n\nCLICINTIE1: 1\n\nCLICIPRIO1: 128\n\nCLICINTATTR1: 0x01\n\n\nSimple CLIC test complete\n\n\n=== Basic Interrupt Functionality ===\n\n\nConfiguring IRQ 1 with priority 128...\n\nTriggering IRQ 1...\n\n\u2717 IRQ 1 was not handled!\n\n\nConfiguring IRQ 3 with priority 128...\n\nTriggering IRQ 3...\n\n\u2717 IRQ 3 was not handled!\n\n\nConfiguring IRQ 5 with priority 128...\n\nTriggering IRQ 5...\n\n\u2717 IRQ 5 was not handled!\n\n\nConfiguring IRQ 7 with priority 128...\n\nTriggering IRQ 7...\n\n\u2717 IRQ 7 was not handled!\n\n\nConfiguring IRQ 9 with priority 128...\n\nTriggering IRQ 9...\n\n\u2717 IRQ 9 was not handled!\n\n\n=== Priority-based Preemption ===\n\nTriggering both interrupts simultaneously...\n\nResults:\n\n  Low priority IRQ 2: count=0\n\n  High priority IRQ 4: count=0\n\n\n=== Interrupt Threshold ===\n\n\nSetting threshold to 100...\n\nResults with threshold=100:\n\n  IRQ 10 (priority=50): count=0 \u2713 (allowed)\n\n  IRQ 11 (priority=128): count=0 \u2717 (blocked)\n\n  IRQ 12 (priority=200): count=0 \u2717 (blocked)\n\n\n=== Test 4: Edge vs Level Triggering ===\n\n\nConfiguring IRQ 15 as edge-triggered...\n\nConfiguring IRQ 16 as level-triggered...\n\n\nTesting edge-triggered interrupt...\n\n  Edge IRQ 15: count=0 (should be 1)\n\n\nTesting level-triggered interrupt...\n\n  Level IRQ 16: count=0\n\n\n=== Interrupt Latency Measurement ===\n\nMeasuring interrupt latency over 10 iterations...\n\n  Iteration 1: TIMEOUT\n\n  Iteration 2: TIMEOUT\n\n  Iteration 3: TIMEOUT\n\n  Iteration 4: TIMEOUT\n\n  Iteration 5: TIMEOUT\n\n  Iteration 6: TIMEOUT\n\n  Iteration 7: TIMEOUT\n\n  Iteration 8: TIMEOUT\n\n  Iteration 9: TIMEOUT\n\n  Iteration 10: TIMEOUT\n\n\n=== Multiple Simultaneous Interrupts ===\n\nConfigured IRQ 25 with priority 50\n\nConfigured IRQ 26 with priority 80\n\nConfigured IRQ 27 with priority 110\n\nConfigured IRQ 28 with priority 140\n\nConfigured IRQ 29 with priority 170\n\n\nTriggering all 5 interrupts simultaneously...\n\n\nResults:\n\n  IRQ 25: handled 0 times\n\n  IRQ 26: handled 0 times\n\n  IRQ 27: handled 0 times\n\n  IRQ 28: handled 0 times\n\n  IRQ 29: handled 0 times\n\n\nClic tests finished\n</code></pre> <p>Test Results Analysis :</p> <ol> <li>CLIC Module Works Correctly: The CLIC is properly generating interrupt signals when we trigger them via CSR writes</li> <li>Signals Don't Match CPU Expectations: VexRiscv expects standard external interrupts on its 32-bit interrupt array, but CLIC provides vectored interrupts with ID and priority</li> <li>No Interrupt Handler Entry: The CPU never enters the interrupt handler</li> </ol> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502               \u2502\n\u2502   Minerva     \u2502\n\u2502               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Implementation : Add RISC-V CLIC to Minerva </p>"},{"location":"nav/development/cpu-implementation-guide/#minerva-clint","title":"Minerva CLINT","text":"<p>Features:</p> <ol> <li>Built-in MTIMER unit (optional) implementing timer functionality</li> <li>Software interrupts via external signals only</li> <li>Designed to work with external CLINT or use internal MTIMER</li> </ol>"},{"location":"nav/development/cpu-implementation-guide/#minerva-clic","title":"Minerva CLIC","text":"<p>Features:</p> <ol> <li>Exception Handling: CLIC is treated as a special interrupt type with its own cause code</li> <li>No Threshold Support: Unlike the full CLIC spec, Minerva doesn't implement threshold-based filtering</li> </ol> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502               \u2502\n\u2502   Ibex        \u2502\n\u2502               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"nav/development/cpu-implementation-guide/#ibex-clint","title":"Ibex CLINT","text":"<p>Already supported.</p>"},{"location":"nav/development/cpu-implementation-guide/#ibex-clic","title":"Ibex CLIC","text":"<p>Implementation : Add RISC-V CLIC to IBEX </p> <p>Features:</p> <ol> <li>Simple mapping : CLIC interrupts are mapped to the 15 fast interrupt lines using the lower 4 bits of the CLIC ID</li> <li>Priority handling: Basic threshold comparison for interrupt filtering</li> <li>Claim generation: Generates claim pulse when interrupt transitions from pending to cleared</li> </ol>"},{"location":"nav/development/development-guide/","title":"Milestones","text":""},{"location":"nav/development/development-guide/#cpu-implementation","title":"CPU Implementation","text":"<p>For detailed information about implementing the CLINT/CLIC interface in a RISC-V CPU, see the CPU Implementation Guide.</p>"},{"location":"nav/development/development-guide/#litex-implementation","title":"Litex Implementation","text":"<p>Add RISC-V CLIC and CLINT interrupt controller support has been posted to support for the RISC-V Core Local Interrupt Controller (CLIC) and the CLINT (Core Local Interruptor) in the LiteX SoC framework.</p>"},{"location":"nav/development/development-guide/#zephyr-implementation","title":"Zephyr Implementation","text":"<p>Add Litex CLIC support to Zephyr has been posted to support for the RISC-V Core Local Interrupt Controller (CLIC) for LiteX SoC framework in Zephyr RTOS.</p>"},{"location":"nav/development/development-guide/#hardware-changes","title":"Hardware Changes","text":"<p>There are two Interrupt Controller Implementations that have been added to Litex SOC framework which enables LiteX-based RISC-V SoCs to choose between CLINT and CLIC.</p> <p>Both controllers expose standardized signals for integration:</p> <ul> <li> <p>CLINT: </p> <ul> <li><code>timer_interrupt</code></li> <li><code>software_interrupt</code></li> </ul> </li> <li> <p>CLIC: </p> <ul> <li><code>clic_interrupt</code></li> <li><code>clic_interrupt_id</code></li> <li><code>clic_interrupt_priority</code></li> </ul> </li> </ul>"},{"location":"nav/development/development-guide/#clint-hardware-integration-in-litex","title":"CLINT Hardware Integration in Litex","text":"<p>The basic RISC-V interrupt architecture defined in the RISC-V privileged specification, using CSRs (Control and Status Registers) like mie and mip for interrupt management.</p>"},{"location":"nav/development/development-guide/#summary-of-changes","title":"Summary of Changes:","text":"<ol> <li> <p>CLINT Core Module (<code>litex/soc/cores/clint.py</code>):</p> <ul> <li>Multi-HART support with configurable <code>num_harts</code> parameter.</li> <li>Separate timer and software interrupt outputs per HART.</li> <li>64-bit <code>MTIME</code> counter with auto-increment.</li> <li>Per-HART 64-bit <code>MTIMECMP</code> registers.</li> <li>Per-HART <code>MSIP</code> bits for software interrupts.</li> <li>CSR-based register interface with proper naming.</li> <li>Helper method <code>add_to_soc()</code> for easy integration.</li> </ul> </li> <li> <p>Minerva CPU Updates (<code>litex/soc/cores/cpu/minerva/core.py</code>):</p> <ul> <li>Added CLINT interrupt support to Minerva CPU.</li> </ul> </li> <li> <p>Ibex CPU Updates (<code>litex/soc/cores/cpu/ibex/core.py</code>):</p> <ul> <li>Added CLINT interrupt support to Ibex CPU.</li> </ul> </li> <li> <p>VexRiscv CPU Updates (<code>litex/soc/cores/cpu/vexriscv/core.py</code>):</p> <ul> <li>Added CLINT interrupt support to VexRiscv CPU.</li> </ul> </li> <li> <p>SoCCore Support (<code>litex/soc/integration/soc_core.py</code>):</p> <ul> <li>Added CLINT parameters (<code>--with-clint</code>).</li> <li>CLINT instantiation for compatible CPUs.</li> </ul> </li> <li> <p>Software Support (<code>.../irq.h</code>, <code>.../clint.h</code>):</p> <ul> <li>Generic Interrupt Service Routines (ISRs) to handle timer and software interrupts.</li> <li>C functions for CLINT configuration and control provided via <code>clint.h</code>.</li> </ul> </li> </ol> <p>The implementation of the CLINT design is compliant with both the older SiFive CLINT design and the newer RISC-V ACLINT specification.</p>"},{"location":"nav/development/development-guide/#clic-hardware-integration-in-litex","title":"CLIC Hardware Integration in Litex","text":"<p>An advanced interrupt controller that provides enhanced features for real-time applications.</p>"},{"location":"nav/development/development-guide/#summary-of-changes_1","title":"Summary of Changes:","text":"<ol> <li> <p>CLIC Core Module (<code>litex/soc/cores/clic.py</code>):</p> <ul> <li>Implements RISC-V CLIC specification features.</li> <li>Supports up to 4096 interrupts with configurable priority.</li> <li>Edge/level trigger configuration per interrupt.</li> <li>Hardware priority arbitration and interrupt preemption.</li> <li>CSR interface for configuration registers.</li> </ul> </li> <li> <p>Minerva CPU Updates (<code>litex/soc/cores/cpu/minerva/core.py</code>):</p> <ul> <li>Added CLIC interrupt signals (interrupt request, ID, priority).</li> <li>Automatic CLIC instantiation when CPU has CLIC support.</li> <li>Defined CLIC memory address region.</li> </ul> </li> <li> <p>Ibex CPU Updates (<code>litex/soc/cores/cpu/ibex/core.py</code>):</p> <ul> <li>Added CLIC interrupt signals (interrupt request, ID, priority).</li> <li>Automatic CLIC instantiation when CPU has CLIC support.</li> <li>Defined CLIC memory address region.</li> </ul> </li> <li> <p>VexRiscv CPU Updates (<code>litex/soc/cores/cpu/vexriscv/core.py</code>):</p> <ul> <li>Added CLIC interrupt support to VexRiscv CPU.</li> </ul> </li> <li> <p>SoC Integration (<code>litex/soc/integration/soc.py</code>):</p> <ul> <li>Added <code>add_clic()</code> method for easy CLIC integration.</li> <li>Automatic connection of interrupt sources to CLIC inputs.</li> <li>CSR mapping for CLIC configuration.</li> </ul> </li> <li> <p>SoCCore Support (<code>litex/soc/integration/soc_core.py</code>):</p> <ul> <li>Added CLIC parameters (<code>--with-clic</code>, <code>--clic-num-interrupts</code>, <code>--clic-ipriolen</code>).</li> <li>CLIC instantiation for compatible CPUs.</li> </ul> </li> </ol>"},{"location":"nav/development/development-guide/#software-changes","title":"Software Changes","text":"<p>The CLINT/CLIC Interrupt Controller Implementations if enabled in LiteX-based RISC-V SoCs can be accessed via software.</p>"},{"location":"nav/development/development-guide/#clint-software-integration-in-litex","title":"CLINT Software Integration in Litex","text":"<ol> <li> <p>Software Driver (<code>.../irq.h</code>, <code>.../clint.h</code>):</p> <ul> <li>Provides generic Interrupt Service Routines (ISRs) for handling timer and software interrupts.</li> <li>Includes C functions for configuring and controlling the CLINT via <code>clint.h</code>.</li> </ul> </li> <li> <p>Software Demo Application (<code>clint_demo.c</code>):</p> <ul> <li>Demonstrates triggering and handling software interrupts using the CLINT.</li> <li>Offers a practical example of utilizing the CLINT C API.</li> </ul> </li> </ol>"},{"location":"nav/development/development-guide/#clic-software-integration-in-litex","title":"CLIC Software Integration in Litex","text":"<ol> <li> <p>Software Driver (<code>.../irq.h</code>, <code>.../clic.h</code>):</p> <ul> <li>Implements generic ISRs for managing prioritized external interrupts.</li> <li>Supplies C functions for configuring and controlling the CLIC via <code>clic.h</code>.</li> <li>Features interrupt enable/disable, priority configuration, and attribute settings.</li> <li>Supports direct CSR access for the first 16 interrupts.</li> </ul> </li> <li> <p>Software Demo Application (<code>clic_demo.c</code>):</p> <ul> <li>Highlights advanced interrupt capabilities of the CLIC.</li> <li>Includes tests for priority-based preemption, interrupt thresholding, and edge/level-triggered modes.</li> <li>Serves as a detailed example of using the CLIC C API effectively.</li> </ul> </li> </ol>"},{"location":"nav/development/development-guide/#linux-implementation","title":"Linux Implementation","text":"<p>VexRiscv-SMP Litex SOC which is capable of booting Linux already supports CLINT Interrupt Controller. CLIC implementation has been added to VexRiscv-SMP Litex SOC with below Pull-Request:</p> <ul> <li>Adding CLIC support to VexRiscv SMP CPU.</li> <li>Adding CLIC support to Linux-on-LiteX SoC.</li> <li>Adding CLIC support to RISCV Opensbi</li> </ul>"},{"location":"nav/development/development-guide/#hardware-changes_1","title":"Hardware Changes","text":""},{"location":"nav/development/development-guide/#summary-of-changes_2","title":"Summary of Changes:","text":""},{"location":"nav/development/development-guide/#vexriscv-smp-cpu-core","title":"VexRiscv SMP CPU Core","text":"<ul> <li><code>VexRiscv/src/main/scala/vexriscv/demo/smp/VexRiscvSmpLitexCluster.scala</code><ul> <li>Added command-line option <code>--with-clic</code></li> <li>Modified CSR configuration to use <code>CsrPluginConfig.withClic()</code> when enabled</li> </ul> </li> </ul>"},{"location":"nav/development/development-guide/#litex-soc-with-vexriscv-smp-cpu-core","title":"Litex SOC with VexRiscv SMP CPU Core","text":"<ul> <li><code>litex/litex/soc/cores/cpu/vexriscv_smp/core.py</code><ul> <li>Added CLIC support detection and signal creation</li> <li>Added <code>--with-clic</code> command-line argument to pass it to Verilog generator</li> </ul> </li> </ul>"},{"location":"nav/development/development-guide/#linux-on-litex-integration","title":"Linux-on-LiteX Integration","text":"<ul> <li> <p><code>linux-on-litex-vexriscv/sim.py</code></p> <ul> <li>Sets <code>VexRiscvSMP.with_clic = True</code> before SoC creation</li> <li>Adds CLIC controller to simulated SoC when <code>--with-clic</code> is specified</li> </ul> </li> <li> <p><code>linux-on-litex-vexriscv/make.py</code></p> <ul> <li>Similar CLIC integration for hardware builds</li> <li>Validates CPU has CLIC support before adding controller</li> </ul> </li> </ul>"},{"location":"nav/development/development-guide/#software-changes_1","title":"Software Changes","text":""},{"location":"nav/development/development-guide/#summary-of-changes_3","title":"Summary of Changes:","text":""},{"location":"nav/development/development-guide/#clic-software-integration-in-opensbi","title":"CLIC Software Integration in Opensbi","text":"<ul> <li><code>opensbi/platform/litex/vexriscv/platform.c</code><ul> <li>Added CLIC support detection and handling interrupts</li> </ul> </li> </ul>"},{"location":"nav/development/development-guide/#clic-node-generation-in-device-tree","title":"CLIC Node Generation in Device Tree","text":"<ul> <li> <p><code>litex/litex/soc/cores/cpu/vexriscv_smp/core.py</code></p> <ul> <li>Added <code>clic_base = 0xf200_0000</code></li> <li>Updated <code>mem_map</code> property to include CLIC when enabled</li> </ul> </li> <li> <p><code>litex/litex/soc/integration/soc.py</code></p> <ul> <li>Modified <code>add_clic()</code> to add CLIC memory region to bus</li> <li>Added <code>self.bus.add_region(\"clic\", SoCRegion(...))</code> for proper device tree generation</li> </ul> </li> <li> <p><code>litex/litex/soc/integration/soc_core.py</code></p> <ul> <li>Updated CLIC initialization to use CPU's CLIC base address from memory map</li> </ul> </li> <li> <p><code>litex/litex/tools/litex_json2dts_linux.py</code></p> <ul> <li>Added complete CLIC device tree generation support</li> <li>Updated interrupt parent references to use CLIC when available</li> </ul> </li> </ul>"},{"location":"nav/development/development-guide/#linux-kernel-driver","title":"Linux Kernel Driver","text":"<ul> <li> <p><code>linux-on-litex-vexriscv/buildroot/patches/linux/6.9/0021-LiteX-driver-for-RISC-V-CLIC.patch</code></p> <ul> <li>Added complete Linux CLIC driver to buildroot</li> </ul> </li> <li> <p><code>linux-on-litex-vexriscv/buildroot/buildroot/board/litex_vexriscv/linux.config</code></p> <ul> <li>Enable CLIC driver in Vexriscv kernel config</li> </ul> </li> </ul>"},{"location":"nav/development/development-guide/#testing","title":"Testing","text":""},{"location":"nav/development/development-guide/#summary-of-changes_4","title":"Summary of Changes:","text":""},{"location":"nav/development/development-guide/#litex-generated-clic-dut-test-framework","title":"LiteX-Generated CLIC DUT Test Framework","text":"<p>A complete cocotb test framework for CLIC using LiteX-generated DUT has been created :</p> <ul> <li>CLIC Cocotb Test Framework</li> </ul>"},{"location":"nav/development/development-guide/#components-created","title":"Components Created","text":""},{"location":"nav/development/development-guide/#1-litex-dut-generator-wrappersgenerate_clicpy","title":"1. LiteX DUT Generator (<code>wrappers/generate_clic.py</code>)","text":"<ul> <li>Purpose: Generates CLIC hardware using LiteX framework</li> <li>Features:</li> <li>Full CLIC implementation from <code>litex.soc.cores.clic</code></li> <li>Wishbone slave interface for CSR access</li> <li>Configurable number of interrupts (default: 16)</li> <li>Proper CSR memory mapping at 0xf0c00000</li> <li>Complete interrupt signaling interface</li> </ul>"},{"location":"nav/development/development-guide/#2-generated-files","title":"2. Generated Files","text":"<ul> <li><code>build_clic/gateware/dut.v</code>: Complete CLIC Verilog implementation (~106KB)</li> <li><code>csr_clic.csv</code>: CSR register map with all CLIC registers</li> <li><code>tb_clic_litex.v</code>: Testbench wrapper for cocotb compatibility</li> </ul>"},{"location":"nav/development/development-guide/#3-test-infrastructure","title":"3. Test Infrastructure","text":"<ul> <li><code>test_clic_litex.py</code>: Main test suite with 7 test functions</li> <li><code>tests/test_clic_litex_basic.py</code>: Basic functionality tests</li> <li><code>tests/test_clic_litex_priority.py</code>: Priority arbitration tests  </li> <li><code>tests/test_clic_litex_csr.py</code>: CSR access tests</li> <li><code>tests/test_clic_litex_performance.py</code>: Performance measurement tests</li> </ul>"},{"location":"nav/development/development-guide/#how-it-works","title":"How It Works","text":""},{"location":"nav/development/development-guide/#litex-generation-process","title":"LiteX Generation Process","text":"<pre><code># The generate_clic.py script:\n1. Creates a CLICTestSoC with CLIC module\n2. Maps CSR registers at 0xf0c00000\n3. Connects wishbone interface\n4. Wires CLIC interrupt signals\n5. Generates synthesizable Verilog\n</code></pre>"},{"location":"nav/development/development-guide/#test-flow","title":"Test Flow","text":"<pre><code>1. Generate DUT: python3 wrappers/generate_clic.py\n2. Compile: pytest test_clic_litex.py::test_compile_litex_clic\n3. Test: pytest test_clic_litex.py::test_litex_clic_basic\n</code></pre>"},{"location":"nav/development/development-guide/#test-coverage","title":"Test Coverage","text":""},{"location":"nav/development/development-guide/#functional-tests","title":"Functional Tests","text":"<p>\u2705 Compilation: Successful</p> <p>\u2705 Basic Test: Interrupt generation and acknowledgment</p> <p>\u2705 Individual Interrupts: Parameterized testing (0-3)</p> <p>\u2705 CSR Access: Wishbone register read/write</p> <p>\u2705 Priority Arbitration: Multi-interrupt priority handling</p>"},{"location":"nav/development/development-guide/#performance-tests","title":"Performance Tests","text":"<p>\u2705 Interrupt Latency: Time required to handle interrupts</p> <p>\u2705 Interrupt Throughput: Interrupts per second measurement</p> <p>\u2705 Priority Switch Time: Time required to switch between interrupts   </p> <p>\u2705 Acknowledgment Time: Time required to acknowledge an interrupt</p>"},{"location":"nav/development/development-guide/#clic-integration-with-full-system","title":"CLIC Integration with Full System","text":"<p>LiteX-generated CLIC can be integrated into a complete SoC:</p> <pre><code>from litex.soc.cores.clic import CLIC\n\nclass MySoC(SoCCore):\n    def __init__(self):\n        # Add CLIC to your SoC\n        self.submodules.clic = CLIC(num_interrupts=64)\n        self.clic.add_csr_interface(self)\n\n        # Connect to CPU\n        self.cpu.clicInterrupt.eq(self.clic.clicInterrupt[0])\n        # ... other connections\n</code></pre>"},{"location":"nav/styles/colors/","title":"Colors","text":""},{"location":"nav/styles/colors/#introduction","title":"Introduction","text":"<p>By integrating RISC-V Advanced Interrupt Architecture (AIA) support into the LiteX SoC framework, we aim to enhance LiteX with modern interrupt handling capabilities that support message-signaled interrupts (MSIs), virtualization, and improved scalability for multi-core systems.</p>"},{"location":"nav/styles/colors/#background","title":"Background","text":"<p>The RISC-V Advanced Interrupt Architecture (AIA) represents the next generation of interrupt handling for RISC-V systems, offering significant advantages over traditional interrupt controllers:</p> <p>Message-Signaled Interrupts (MSIs): Direct support for PCIe and other modern peripheral standards Virtualization Support: Hardware-assisted interrupt virtualization for guest VMs Scalability: Support for up to 16,384 harts with thousands of interrupt sources Flexible Priority Management: Software-configurable interrupt priorities across all interrupt types Improved Latency: Hardware acceleration for interrupt delivery and handling</p>"}]}