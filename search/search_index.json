{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Introduction LiteX refers primarily to the process of defining and building hardware designs, including IP components and entire System-on-Chips (SoCs), using the Migen Python internal Domain Specific Language (DSL). The LiteX library contains a collection of soft RISC-V processor cores and IP components, such as DRAM controllers, Ethernet cores, PCIe, SATA, HDMI, and more, which are described using this Migen/Python approach. In this project we are targetting adding an Interrupt Controller.","title":"Home"},{"location":"#home","text":"","title":"Home"},{"location":"#introduction","text":"LiteX refers primarily to the process of defining and building hardware designs, including IP components and entire System-on-Chips (SoCs), using the Migen Python internal Domain Specific Language (DSL). The LiteX library contains a collection of soft RISC-V processor cores and IP components, such as DRAM controllers, Ethernet cores, PCIe, SATA, HDMI, and more, which are described using this Migen/Python approach. In this project we are targetting adding an Interrupt Controller.","title":"Introduction"},{"location":"nav/getting-started/","text":"Getting Started LiteX, as a SoC builder and library, directly supports the RISC-V trend by making RISC-V softcores instantiable. Specifically, VexRiscv RISC-V cores support is very mature with the availibilty to support both RTOS and Linux. RISC-V supports multiple types of interrupt controllers, depending on the implementation and platform as shown below : Controller Scope Interrupt Types Prioritization Nesting Use Case CLINT Core-local Timer, software Minimal No Simple, non-virtualized system CLIC Core-local Local Fine-grained Yes RTOS, embedded systems PLIC Platform-level External (global) Coarse No Linux, multiprocessor systems CSRs Core-local Timer, software, external Minimal No Bare-metal, low-level control By integrating RISC-V CLIC support into the LiteX SoC framework, we aim to enhance LiteX with modern interrupt handling capabilities. Instead it currently uses custom, memory-mapped peripheral for each RISC-V CPU cores.","title":"Getting Started"},{"location":"nav/getting-started/#getting-started","text":"LiteX, as a SoC builder and library, directly supports the RISC-V trend by making RISC-V softcores instantiable. Specifically, VexRiscv RISC-V cores support is very mature with the availibilty to support both RTOS and Linux. RISC-V supports multiple types of interrupt controllers, depending on the implementation and platform as shown below : Controller Scope Interrupt Types Prioritization Nesting Use Case CLINT Core-local Timer, software Minimal No Simple, non-virtualized system CLIC Core-local Local Fine-grained Yes RTOS, embedded systems PLIC Platform-level External (global) Coarse No Linux, multiprocessor systems CSRs Core-local Timer, software, external Minimal No Bare-metal, low-level control By integrating RISC-V CLIC support into the LiteX SoC framework, we aim to enhance LiteX with modern interrupt handling capabilities. Instead it currently uses custom, memory-mapped peripheral for each RISC-V CPU cores.","title":"Getting Started"},{"location":"nav/architecture/overview/","text":"Overview This diagram shows how PLIC handles external interrupt distribution while CLIC provides advanced local interrupt management, creating a comprehensive interrupt handling solution for the Litex SOC. Architecture Diagram The following diagram illustrates the comprehensive interrupt handling architecture, showing how PLIC manages external interrupt sources while CLIC provides advanced local interrupt management for the CPU core. \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Litex SOC with PLIC + CLIC \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2502 External Interrupt Sources \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 interrupts[31:1] \u2502 \u2502 \u2502 \u2502 \u2022 UART \u2502 \u2502 \u2502 \u2502 \u2022 GPIO \u2502 \u2502 \u2502 \u2502 \u2022 Ethernet \u2502 \u2502 \u2502 \u2502 \u2022 DMA \u2502 \u2502 \u2502 \u2502 \u2022 ... \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u25bc \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 PLIC Controller \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 Gateway \u2502 \u2502 Priority \u2502 \u2502 Targets \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Logic \u2502 \u2502 Arbitration \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502\u2500\u2500\u2500\u25b6\u2502 Tree-based \u2502\u2500\u2500\u2500\u25b6\u2502 \u2502 M \u2502 S \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Edge \u2502 \u2502 Priority \u2502 \u2502 \u2502Mode\u2502Mode \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Detect \u2502 \u2502 Selection \u2502 \u2502 \u2514\u2500\u252c\u2500\u2500\u2534\u2500\u2500\u252c\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Local Interrupt Sources: \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 \u2022 Timer Compare \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 (MTIMECMP vs MTIME) \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2022 Software Trigger \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 (MSIP register) \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u25bc \u25bc \u25bc \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Riscv CPU Core \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Interrupt Interfaces: Memory Interfaces: \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 PLIC: \u2502 \u2502 \u2022 iBus \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2022 Machine External \u2502 \u2502 \u2022 dBus \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2022 Supervisor Ext \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Cache: I/D$ 4KB \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 CLIC: \u2502 \u2502 Width: 32-bit \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2022 interrupt_valid \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2022 interrupt_id[7:0] \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2022 interrupt_level \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2022 interrupt_priv \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2022 mtvec_addr \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2022 mtvec_mode \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Additional CSRs: \u2502 \u2502 \u2502 \u2502 \u2022 mintthresh, mtvt, mnxti, mintstatus \u2502 \u2502 \u2502 \u2502 \u2022 mscratchcsw, mnscratchcsw \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Benefits of PLIC + CLIC Architecture: PLIC: System-wide external interrupt distribution and prioritization CLIC: Advanced per-hart interrupt management with vectoring and preemption Unified: Single interrupt interface to CPU with enhanced capabilities Scalable: Easy to extend to multiple cores while maintaining per-hart CLIC benefits","title":"Overview"},{"location":"nav/architecture/overview/#overview","text":"This diagram shows how PLIC handles external interrupt distribution while CLIC provides advanced local interrupt management, creating a comprehensive interrupt handling solution for the Litex SOC.","title":"Overview"},{"location":"nav/architecture/overview/#architecture-diagram","text":"The following diagram illustrates the comprehensive interrupt handling architecture, showing how PLIC manages external interrupt sources while CLIC provides advanced local interrupt management for the CPU core. \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Litex SOC with PLIC + CLIC \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2502 External Interrupt Sources \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 interrupts[31:1] \u2502 \u2502 \u2502 \u2502 \u2022 UART \u2502 \u2502 \u2502 \u2502 \u2022 GPIO \u2502 \u2502 \u2502 \u2502 \u2022 Ethernet \u2502 \u2502 \u2502 \u2502 \u2022 DMA \u2502 \u2502 \u2502 \u2502 \u2022 ... \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u25bc \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 PLIC Controller \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 Gateway \u2502 \u2502 Priority \u2502 \u2502 Targets \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Logic \u2502 \u2502 Arbitration \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502\u2500\u2500\u2500\u25b6\u2502 Tree-based \u2502\u2500\u2500\u2500\u25b6\u2502 \u2502 M \u2502 S \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Edge \u2502 \u2502 Priority \u2502 \u2502 \u2502Mode\u2502Mode \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Detect \u2502 \u2502 Selection \u2502 \u2502 \u2514\u2500\u252c\u2500\u2500\u2534\u2500\u2500\u252c\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Local Interrupt Sources: \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 \u2022 Timer Compare \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 (MTIMECMP vs MTIME) \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2022 Software Trigger \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 (MSIP register) \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u25bc \u25bc \u25bc \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Riscv CPU Core \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Interrupt Interfaces: Memory Interfaces: \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 PLIC: \u2502 \u2502 \u2022 iBus \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2022 Machine External \u2502 \u2502 \u2022 dBus \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2022 Supervisor Ext \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Cache: I/D$ 4KB \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 CLIC: \u2502 \u2502 Width: 32-bit \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2022 interrupt_valid \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2022 interrupt_id[7:0] \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2022 interrupt_level \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2022 interrupt_priv \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2022 mtvec_addr \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2022 mtvec_mode \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Additional CSRs: \u2502 \u2502 \u2502 \u2502 \u2022 mintthresh, mtvt, mnxti, mintstatus \u2502 \u2502 \u2502 \u2502 \u2022 mscratchcsw, mnscratchcsw \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Benefits of PLIC + CLIC Architecture: PLIC: System-wide external interrupt distribution and prioritization CLIC: Advanced per-hart interrupt management with vectoring and preemption Unified: Single interrupt interface to CPU with enhanced capabilities Scalable: Easy to extend to multiple cores while maintaining per-hart CLIC benefits","title":"Architecture Diagram"},{"location":"nav/components/footer/","text":"Footer Introduction By integrating RISC-V CLIC (Core-Local Interrupt Controller) support into the LiteX SoC framework, we aim to enhance LiteX with modern interrupt handling capabilities that support more advanced and flexible interrupt controller with features like nested interrupts, per-interrupt priority levels, and vectored interrupt handling. Features Up to 4096 interrupts. Each interrupt can have a configurable priority and trigger mode (level/edge). Supports vectored interrupt mode (faster response time). Designed to be memory-mapped and visible to software. Use Case: Embedded and real-time systems that need fine-grained interrupt control. Status: Still a draft specification (as of 06/2025), but adopted by some vendors like SiFive.","title":"Footer"},{"location":"nav/components/footer/#footer","text":"","title":"Footer"},{"location":"nav/components/footer/#introduction","text":"By integrating RISC-V CLIC (Core-Local Interrupt Controller) support into the LiteX SoC framework, we aim to enhance LiteX with modern interrupt handling capabilities that support more advanced and flexible interrupt controller with features like nested interrupts, per-interrupt priority levels, and vectored interrupt handling.","title":"Introduction"},{"location":"nav/components/footer/#features","text":"Up to 4096 interrupts. Each interrupt can have a configurable priority and trigger mode (level/edge). Supports vectored interrupt mode (faster response time). Designed to be memory-mapped and visible to software.","title":"Features"},{"location":"nav/components/footer/#use-case","text":"Embedded and real-time systems that need fine-grained interrupt control.","title":"Use Case:"},{"location":"nav/components/footer/#status","text":"Still a draft specification (as of 06/2025), but adopted by some vendors like SiFive.","title":"Status:"},{"location":"nav/development/cpu-implementation-guide/","text":"Riscv Interrupt Controller CPU CLINT Implementation Feature VexRiscv Minerva Ibex Implementation Inbuilt Support Implemented natively Inbuilt Support CPU CLIC Implementation Feature VexRiscv Minerva Ibex Implementation Plugin-based Implemented natively External wrapper Configuration Compile-time option Always present Added post-generation Vectored mode Configurable Not visible Not supported Generation SpinalHDL \u2192 Verilog Amaranth \u2192 Verilog Direct SystemVerilog \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Vexriscv \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Vexriscv CLINT CLINT handling is already supported from before inside Vexriscv CPU. Below tests show CLINT fully functional on Vexricv. CLINT Tests ( clint_demo.c ) It contains several tests that trigger and handle software interrupts. Below logs show the result of running clint_demo on Vexriscv Litex Soc: LiteX minimal demo app built Jul 18 2025 14:18:51 Available commands: help - Show this command reboot - Reboot CPU donut - Spinning Donut demo helloc - Hello C clint - CLINT software interrupt demo litex-demo-app> CLINT demo... CLINT base address: 0xf0000000 CLINT initialized for software interrupts === Testing CLINT->CPU connection === Software interrupt handled! Count: 1 Test FAILED: MIP.MSIP does not respond to CLINT MSIP This indicates CLINT is not properly connected to CPU === CSR Manipulation Test === Test PASSED: MIP.MSIP is read-only as expected === Memory barrier Test === Software interrupt handled! Count: 2 Test FAILED: MIP.MSIP does not respond correctly to MSIP changes === Basic Software Interrupt test === Triggering software interrupt... Software interrupt handled! Count: 3 Triggering software interrupt... Software interrupt handled! Count: 4 Triggering software interrupt... Software interrupt handled! Count: 5 Triggering software interrupt... Software interrupt handled! Count: 6 Triggering software interrupt... Software interrupt handled! Count: 7 Total interrupts handled: 7 === Interrupt Enable/Disable test === Good: Interrupt was not handled while disabled Triggering software interrupt... Software interrupt handled! Count: 8 Good: Interrupt was handled after re-enabling ==== CLINT Demo Complete ==== Vexriscv CLIC CLIC handling is being inside Vexriscv CPU with below Implementation: Add RISC-V CLIC to Vexriscv Add RISC-V CLIC to Vexriscv Configuration Features: Plugin based : CSR Plugin has been extended to support CLIC. Configuration based: CLIC implentation can be intergrated in any configuration. CLIC Tests ( clic_demo.c ) It contains several tests that interrupt enable/disable, priority configuration, and attribute settings. Below logs show the result of running clic_demo on Vexriscv Litex Soc: LiteX minimal demo app built Jul 18 2025 12:18:28 Available commands: help - Show this command reboot - Reboot CPU donut - Spinning Donut demo helloc - Hello C clic - CLIC interrupt controller demo litex-demo-app> CLIC demo... Initializing CLIC... CLIC initialized === CLIC CSR Access Test === CSR_BASE: 0xf0000000 CSR_CLIC_BASE: 0xf0000000 Testing interrupt 0 CSRs: CLICINTIE0 addr: 0xf0000000 CLICINTIP0 addr: 0xf0000004 CLICIPRIO0 addr: 0xf0000008 CLICINTATTR0 addr: 0xf000000c Wrote 1 to CLICINTIE0 Read back CLICINTIE0: 1 Configured interrupt 0: priority=128, edge triggered Triggering interrupt 0... CLICINTIP0 after trigger: 1 CLICINTIP0 after clear: 0 === Simple CLIC Test === CSR_BASE: 0xf0000000 CSR_CLIC_BASE: 0xf0000000 Configuring interrupt 1... Global interrupts enabled Test 1: Triggering interrupt 1 via CSR write... FAILED: Interrupt was not handled Test 2: Testing pending bit read/write... After setting: pending = 1 After clearing: pending = 0 Test 3: Reading configuration CSRs... CLICINTIE1: 1 CLICIPRIO1: 128 CLICINTATTR1: 0x01 Simple CLIC test complete === Basic Interrupt Functionality === Configuring IRQ 1 with priority 128... Triggering IRQ 1... \u2717 IRQ 1 was not handled! Configuring IRQ 3 with priority 128... Triggering IRQ 3... \u2717 IRQ 3 was not handled! Configuring IRQ 5 with priority 128... Triggering IRQ 5... \u2717 IRQ 5 was not handled! Configuring IRQ 7 with priority 128... Triggering IRQ 7... \u2717 IRQ 7 was not handled! Configuring IRQ 9 with priority 128... Triggering IRQ 9... \u2717 IRQ 9 was not handled! === Priority-based Preemption === Triggering both interrupts simultaneously... Results: Low priority IRQ 2: count=0 High priority IRQ 4: count=0 === Interrupt Threshold === Setting threshold to 100... Results with threshold=100: IRQ 10 (priority=50): count=0 \u2713 (allowed) IRQ 11 (priority=128): count=0 \u2717 (blocked) IRQ 12 (priority=200): count=0 \u2717 (blocked) === Test 4: Edge vs Level Triggering === Configuring IRQ 15 as edge-triggered... Configuring IRQ 16 as level-triggered... Testing edge-triggered interrupt... Edge IRQ 15: count=0 (should be 1) Testing level-triggered interrupt... Level IRQ 16: count=0 === Interrupt Latency Measurement === Measuring interrupt latency over 10 iterations... Iteration 1: TIMEOUT Iteration 2: TIMEOUT Iteration 3: TIMEOUT Iteration 4: TIMEOUT Iteration 5: TIMEOUT Iteration 6: TIMEOUT Iteration 7: TIMEOUT Iteration 8: TIMEOUT Iteration 9: TIMEOUT Iteration 10: TIMEOUT === Multiple Simultaneous Interrupts === Configured IRQ 25 with priority 50 Configured IRQ 26 with priority 80 Configured IRQ 27 with priority 110 Configured IRQ 28 with priority 140 Configured IRQ 29 with priority 170 Triggering all 5 interrupts simultaneously... Results: IRQ 25: handled 0 times IRQ 26: handled 0 times IRQ 27: handled 0 times IRQ 28: handled 0 times IRQ 29: handled 0 times Clic tests finished Test Results Analysis : CLIC Module Works Correctly: The CLIC is properly generating interrupt signals when we trigger them via CSR writes Signals Don't Match CPU Expectations: VexRiscv expects standard external interrupts on its 32-bit interrupt array, but CLIC provides vectored interrupts with ID and priority No Interrupt Handler Entry: The CPU never enters the interrupt handler \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Minerva \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Implementation : Add RISC-V CLIC to Minerva Minerva CLINT Features: Built-in MTIMER unit (optional) implementing timer functionality Software interrupts via external signals only Designed to work with external CLINT or use internal MTIMER Minerva CLIC Features: Exception Handling: CLIC is treated as a special interrupt type with its own cause code No Threshold Support: Unlike the full CLIC spec, Minerva doesn't implement threshold-based filtering \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Ibex \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Ibex CLINT Already supported. Ibex CLIC Implementation : Add RISC-V CLIC to IBEX Features: Simple mapping : CLIC interrupts are mapped to the 15 fast interrupt lines using the lower 4 bits of the CLIC ID Priority handling: Basic threshold comparison for interrupt filtering Claim generation: Generates claim pulse when interrupt transitions from pending to cleared","title":"Riscv Interrupt Controller"},{"location":"nav/development/cpu-implementation-guide/#riscv-interrupt-controller","text":"","title":"Riscv Interrupt Controller"},{"location":"nav/development/cpu-implementation-guide/#cpu-clint-implementation","text":"Feature VexRiscv Minerva Ibex Implementation Inbuilt Support Implemented natively Inbuilt Support","title":"CPU CLINT Implementation"},{"location":"nav/development/cpu-implementation-guide/#cpu-clic-implementation","text":"Feature VexRiscv Minerva Ibex Implementation Plugin-based Implemented natively External wrapper Configuration Compile-time option Always present Added post-generation Vectored mode Configurable Not visible Not supported Generation SpinalHDL \u2192 Verilog Amaranth \u2192 Verilog Direct SystemVerilog \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Vexriscv \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"CPU CLIC Implementation"},{"location":"nav/development/cpu-implementation-guide/#vexriscv-clint","text":"CLINT handling is already supported from before inside Vexriscv CPU. Below tests show CLINT fully functional on Vexricv.","title":"Vexriscv CLINT"},{"location":"nav/development/cpu-implementation-guide/#clint-tests-clint_democ","text":"It contains several tests that trigger and handle software interrupts. Below logs show the result of running clint_demo on Vexriscv Litex Soc: LiteX minimal demo app built Jul 18 2025 14:18:51 Available commands: help - Show this command reboot - Reboot CPU donut - Spinning Donut demo helloc - Hello C clint - CLINT software interrupt demo litex-demo-app> CLINT demo... CLINT base address: 0xf0000000 CLINT initialized for software interrupts === Testing CLINT->CPU connection === Software interrupt handled! Count: 1 Test FAILED: MIP.MSIP does not respond to CLINT MSIP This indicates CLINT is not properly connected to CPU === CSR Manipulation Test === Test PASSED: MIP.MSIP is read-only as expected === Memory barrier Test === Software interrupt handled! Count: 2 Test FAILED: MIP.MSIP does not respond correctly to MSIP changes === Basic Software Interrupt test === Triggering software interrupt... Software interrupt handled! Count: 3 Triggering software interrupt... Software interrupt handled! Count: 4 Triggering software interrupt... Software interrupt handled! Count: 5 Triggering software interrupt... Software interrupt handled! Count: 6 Triggering software interrupt... Software interrupt handled! Count: 7 Total interrupts handled: 7 === Interrupt Enable/Disable test === Good: Interrupt was not handled while disabled Triggering software interrupt... Software interrupt handled! Count: 8 Good: Interrupt was handled after re-enabling ==== CLINT Demo Complete ====","title":"CLINT Tests (clint_demo.c)"},{"location":"nav/development/cpu-implementation-guide/#vexriscv-clic","text":"CLIC handling is being inside Vexriscv CPU with below Implementation: Add RISC-V CLIC to Vexriscv Add RISC-V CLIC to Vexriscv Configuration Features: Plugin based : CSR Plugin has been extended to support CLIC. Configuration based: CLIC implentation can be intergrated in any configuration.","title":"Vexriscv CLIC"},{"location":"nav/development/cpu-implementation-guide/#clic-tests-clic_democ","text":"It contains several tests that interrupt enable/disable, priority configuration, and attribute settings. Below logs show the result of running clic_demo on Vexriscv Litex Soc: LiteX minimal demo app built Jul 18 2025 12:18:28 Available commands: help - Show this command reboot - Reboot CPU donut - Spinning Donut demo helloc - Hello C clic - CLIC interrupt controller demo litex-demo-app> CLIC demo... Initializing CLIC... CLIC initialized === CLIC CSR Access Test === CSR_BASE: 0xf0000000 CSR_CLIC_BASE: 0xf0000000 Testing interrupt 0 CSRs: CLICINTIE0 addr: 0xf0000000 CLICINTIP0 addr: 0xf0000004 CLICIPRIO0 addr: 0xf0000008 CLICINTATTR0 addr: 0xf000000c Wrote 1 to CLICINTIE0 Read back CLICINTIE0: 1 Configured interrupt 0: priority=128, edge triggered Triggering interrupt 0... CLICINTIP0 after trigger: 1 CLICINTIP0 after clear: 0 === Simple CLIC Test === CSR_BASE: 0xf0000000 CSR_CLIC_BASE: 0xf0000000 Configuring interrupt 1... Global interrupts enabled Test 1: Triggering interrupt 1 via CSR write... FAILED: Interrupt was not handled Test 2: Testing pending bit read/write... After setting: pending = 1 After clearing: pending = 0 Test 3: Reading configuration CSRs... CLICINTIE1: 1 CLICIPRIO1: 128 CLICINTATTR1: 0x01 Simple CLIC test complete === Basic Interrupt Functionality === Configuring IRQ 1 with priority 128... Triggering IRQ 1... \u2717 IRQ 1 was not handled! Configuring IRQ 3 with priority 128... Triggering IRQ 3... \u2717 IRQ 3 was not handled! Configuring IRQ 5 with priority 128... Triggering IRQ 5... \u2717 IRQ 5 was not handled! Configuring IRQ 7 with priority 128... Triggering IRQ 7... \u2717 IRQ 7 was not handled! Configuring IRQ 9 with priority 128... Triggering IRQ 9... \u2717 IRQ 9 was not handled! === Priority-based Preemption === Triggering both interrupts simultaneously... Results: Low priority IRQ 2: count=0 High priority IRQ 4: count=0 === Interrupt Threshold === Setting threshold to 100... Results with threshold=100: IRQ 10 (priority=50): count=0 \u2713 (allowed) IRQ 11 (priority=128): count=0 \u2717 (blocked) IRQ 12 (priority=200): count=0 \u2717 (blocked) === Test 4: Edge vs Level Triggering === Configuring IRQ 15 as edge-triggered... Configuring IRQ 16 as level-triggered... Testing edge-triggered interrupt... Edge IRQ 15: count=0 (should be 1) Testing level-triggered interrupt... Level IRQ 16: count=0 === Interrupt Latency Measurement === Measuring interrupt latency over 10 iterations... Iteration 1: TIMEOUT Iteration 2: TIMEOUT Iteration 3: TIMEOUT Iteration 4: TIMEOUT Iteration 5: TIMEOUT Iteration 6: TIMEOUT Iteration 7: TIMEOUT Iteration 8: TIMEOUT Iteration 9: TIMEOUT Iteration 10: TIMEOUT === Multiple Simultaneous Interrupts === Configured IRQ 25 with priority 50 Configured IRQ 26 with priority 80 Configured IRQ 27 with priority 110 Configured IRQ 28 with priority 140 Configured IRQ 29 with priority 170 Triggering all 5 interrupts simultaneously... Results: IRQ 25: handled 0 times IRQ 26: handled 0 times IRQ 27: handled 0 times IRQ 28: handled 0 times IRQ 29: handled 0 times Clic tests finished Test Results Analysis : CLIC Module Works Correctly: The CLIC is properly generating interrupt signals when we trigger them via CSR writes Signals Don't Match CPU Expectations: VexRiscv expects standard external interrupts on its 32-bit interrupt array, but CLIC provides vectored interrupts with ID and priority No Interrupt Handler Entry: The CPU never enters the interrupt handler \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Minerva \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Implementation : Add RISC-V CLIC to Minerva","title":"CLIC Tests (clic_demo.c)"},{"location":"nav/development/cpu-implementation-guide/#minerva-clint","text":"Features: Built-in MTIMER unit (optional) implementing timer functionality Software interrupts via external signals only Designed to work with external CLINT or use internal MTIMER","title":"Minerva CLINT"},{"location":"nav/development/cpu-implementation-guide/#minerva-clic","text":"Features: Exception Handling: CLIC is treated as a special interrupt type with its own cause code No Threshold Support: Unlike the full CLIC spec, Minerva doesn't implement threshold-based filtering \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Ibex \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Minerva CLIC"},{"location":"nav/development/cpu-implementation-guide/#ibex-clint","text":"Already supported.","title":"Ibex CLINT"},{"location":"nav/development/cpu-implementation-guide/#ibex-clic","text":"Implementation : Add RISC-V CLIC to IBEX Features: Simple mapping : CLIC interrupts are mapped to the 15 fast interrupt lines using the lower 4 bits of the CLIC ID Priority handling: Basic threshold comparison for interrupt filtering Claim generation: Generates claim pulse when interrupt transitions from pending to cleared","title":"Ibex CLIC"},{"location":"nav/development/development-guide/","text":"Milestones CPU Implementation For detailed information about implementing the CLINT/CLIC interface in a RISC-V CPU, see the CPU Implementation Guide . Litex Implementation Add RISC-V CLIC and CLINT interrupt controller support has been posted to support for the RISC-V Core Local Interrupt Controller (CLIC) and the CLINT (Core Local Interruptor) in the LiteX SoC framework. Zephyr Implementation Add Litex CLIC support to Zephyr has been posted to support for the RISC-V Core Local Interrupt Controller (CLIC) for LiteX SoC framework in Zephyr RTOS. Hardware Changes There are two Interrupt Controller Implementations that have been added to Litex SOC framework which enables LiteX-based RISC-V SoCs to choose between CLINT and CLIC. Both controllers expose standardized signals for integration: CLINT: timer_interrupt software_interrupt CLIC: clic_interrupt clic_interrupt_id clic_interrupt_priority CLINT Hardware Integration in Litex The basic RISC-V interrupt architecture defined in the RISC-V privileged specification, using CSRs (Control and Status Registers) like mie and mip for interrupt management. Summary of Changes: CLINT Core Module ( litex/soc/cores/clint.py ): Multi-HART support with configurable num_harts parameter. Separate timer and software interrupt outputs per HART. 64-bit MTIME counter with auto-increment. Per-HART 64-bit MTIMECMP registers. Per-HART MSIP bits for software interrupts. CSR-based register interface with proper naming. Helper method add_to_soc() for easy integration. Minerva CPU Updates ( litex/soc/cores/cpu/minerva/core.py ): Added CLINT interrupt support to Minerva CPU. Ibex CPU Updates ( litex/soc/cores/cpu/ibex/core.py ): Added CLINT interrupt support to Ibex CPU. VexRiscv CPU Updates ( litex/soc/cores/cpu/vexriscv/core.py ): Added CLINT interrupt support to VexRiscv CPU. SoCCore Support ( litex/soc/integration/soc_core.py ): Added CLINT parameters ( --with-clint ). CLINT instantiation for compatible CPUs. Software Support ( .../irq.h , .../clint.h ): Generic Interrupt Service Routines (ISRs) to handle timer and software interrupts. C functions for CLINT configuration and control provided via clint.h . The implementation of the CLINT design is compliant with both the older SiFive CLINT design and the newer RISC-V ACLINT specification . CLIC Hardware Integration in Litex An advanced interrupt controller that provides enhanced features for real-time applications. Summary of Changes: CLIC Core Module ( litex/soc/cores/clic.py ): Implements RISC-V CLIC specification features. Supports up to 4096 interrupts with configurable priority. Edge/level trigger configuration per interrupt. Hardware priority arbitration and interrupt preemption. CSR interface for configuration registers. Minerva CPU Updates ( litex/soc/cores/cpu/minerva/core.py ): Added CLIC interrupt signals (interrupt request, ID, priority). Automatic CLIC instantiation when CPU has CLIC support. Defined CLIC memory address region. Ibex CPU Updates ( litex/soc/cores/cpu/ibex/core.py ): Added CLIC interrupt signals (interrupt request, ID, priority). Automatic CLIC instantiation when CPU has CLIC support. Defined CLIC memory address region. VexRiscv CPU Updates ( litex/soc/cores/cpu/vexriscv/core.py ): Added CLIC interrupt support to VexRiscv CPU. SoC Integration ( litex/soc/integration/soc.py ): Added add_clic() method for easy CLIC integration. Automatic connection of interrupt sources to CLIC inputs. CSR mapping for CLIC configuration. SoCCore Support ( litex/soc/integration/soc_core.py ): Added CLIC parameters ( --with-clic , --clic-num-interrupts , --clic-ipriolen ). CLIC instantiation for compatible CPUs. Software Changes The CLINT/CLIC Interrupt Controller Implementations if enabled in LiteX-based RISC-V SoCs can be accessed via software. CLINT Software Integration in Litex Software Driver ( .../irq.h , .../clint.h ): Provides generic Interrupt Service Routines (ISRs) for handling timer and software interrupts. Includes C functions for configuring and controlling the CLINT via clint.h . Software Demo Application ( clint_demo.c ): Demonstrates triggering and handling software interrupts using the CLINT. Offers a practical example of utilizing the CLINT C API. CLIC Software Integration in Litex Software Driver ( .../irq.h , .../clic.h ): Implements generic ISRs for managing prioritized external interrupts. Supplies C functions for configuring and controlling the CLIC via clic.h . Features interrupt enable/disable, priority configuration, and attribute settings. Supports direct CSR access for the first 16 interrupts. Software Demo Application ( clic_demo.c ): Highlights advanced interrupt capabilities of the CLIC. Includes tests for priority-based preemption, interrupt thresholding, and edge/level-triggered modes. Serves as a detailed example of using the CLIC C API effectively. Linux Implementation VexRiscv-SMP Litex SOC which is capable of booting Linux already supports CLINT Interrupt Controller. CLIC implementation has been added to VexRiscv-SMP Litex SOC with below Pull-Request: Adding CLIC support to VexRiscv SMP CPU . Adding CLIC support to Linux-on-LiteX SoC . Adding CLIC support to RISCV Opensbi Hardware Changes Summary of Changes: VexRiscv SMP CPU Core VexRiscv/src/main/scala/vexriscv/demo/smp/VexRiscvSmpLitexCluster.scala Added command-line option --with-clic Modified CSR configuration to use CsrPluginConfig.withClic() when enabled Litex SOC with VexRiscv SMP CPU Core litex/litex/soc/cores/cpu/vexriscv_smp/core.py Added CLIC support detection and signal creation Added --with-clic command-line argument to pass it to Verilog generator Linux-on-LiteX Integration linux-on-litex-vexriscv/sim.py Sets VexRiscvSMP.with_clic = True before SoC creation Adds CLIC controller to simulated SoC when --with-clic is specified linux-on-litex-vexriscv/make.py Similar CLIC integration for hardware builds Validates CPU has CLIC support before adding controller Software Changes Summary of Changes: CLIC Software Integration in Opensbi opensbi/platform/litex/vexriscv/platform.c Added CLIC support detection and handling interrupts CLIC Node Generation in Device Tree litex/litex/soc/cores/cpu/vexriscv_smp/core.py Added clic_base = 0xf200_0000 Updated mem_map property to include CLIC when enabled litex/litex/soc/integration/soc.py Modified add_clic() to add CLIC memory region to bus Added self.bus.add_region(\"clic\", SoCRegion(...)) for proper device tree generation litex/litex/soc/integration/soc_core.py Updated CLIC initialization to use CPU's CLIC base address from memory map litex/litex/tools/litex_json2dts_linux.py Added complete CLIC device tree generation support Updated interrupt parent references to use CLIC when available Kernel Driver - PENDING Testing Summary of Changes: LiteX-Generated CLIC DUT Test Framework A complete cocotb test framework for CLIC using LiteX-generated DUT has been created : CLIC Cocotb Test Framework Components Created 1. LiteX DUT Generator ( wrappers/generate_clic.py ) Purpose : Generates CLIC hardware using LiteX framework Features : Full CLIC implementation from litex.soc.cores.clic Wishbone slave interface for CSR access Configurable number of interrupts (default: 16) Proper CSR memory mapping at 0xf0c00000 Complete interrupt signaling interface 2. Generated Files build_clic/gateware/dut.v : Complete CLIC Verilog implementation (~106KB) csr_clic.csv : CSR register map with all CLIC registers tb_clic_litex.v : Testbench wrapper for cocotb compatibility 3. Test Infrastructure test_clic_litex.py : Main test suite with 7 test functions tests/test_clic_litex_basic.py : Basic functionality tests tests/test_clic_litex_priority.py : Priority arbitration tests tests/test_clic_litex_csr.py : CSR access tests tests/test_clic_litex_performance.py : Performance measurement tests How It Works LiteX Generation Process # The generate_clic.py script: 1. Creates a CLICTestSoC with CLIC module 2. Maps CSR registers at 0xf0c00000 3. Connects wishbone interface 4. Wires CLIC interrupt signals 5. Generates synthesizable Verilog Test Flow 1. Generate DUT: python3 wrappers/generate_clic.py 2. Compile: pytest test_clic_litex.py::test_compile_litex_clic 3. Test: pytest test_clic_litex.py::test_litex_clic_basic Test Coverage Functional Tests \u2705 Compilation : Successful \u2705 Basic Test : Interrupt generation and acknowledgment \u2705 Individual Interrupts : Parameterized testing (0-3) \u2705 CSR Access : Wishbone register read/write \u2705 Priority Arbitration : Multi-interrupt priority handling Performance Tests \u2705 Interrupt Latency : Time required to handle interrupts \u2705 Interrupt Throughput : Interrupts per second measurement \u2705 Priority Switch Time : Time required to switch between interrupts \u2705 Acknowledgment Time : Time required to acknowledge an interrupt CLIC Integration with Full System LiteX-generated CLIC can be integrated into a complete SoC: from litex.soc.cores.clic import CLIC class MySoC(SoCCore): def __init__(self): # Add CLIC to your SoC self.submodules.clic = CLIC(num_interrupts=64) self.clic.add_csr_interface(self) # Connect to CPU self.cpu.clicInterrupt.eq(self.clic.clicInterrupt[0]) # ... other connections","title":"Milestones"},{"location":"nav/development/development-guide/#milestones","text":"","title":"Milestones"},{"location":"nav/development/development-guide/#cpu-implementation","text":"For detailed information about implementing the CLINT/CLIC interface in a RISC-V CPU, see the CPU Implementation Guide .","title":"CPU Implementation"},{"location":"nav/development/development-guide/#litex-implementation","text":"Add RISC-V CLIC and CLINT interrupt controller support has been posted to support for the RISC-V Core Local Interrupt Controller (CLIC) and the CLINT (Core Local Interruptor) in the LiteX SoC framework.","title":"Litex Implementation"},{"location":"nav/development/development-guide/#zephyr-implementation","text":"Add Litex CLIC support to Zephyr has been posted to support for the RISC-V Core Local Interrupt Controller (CLIC) for LiteX SoC framework in Zephyr RTOS.","title":"Zephyr Implementation"},{"location":"nav/development/development-guide/#hardware-changes","text":"There are two Interrupt Controller Implementations that have been added to Litex SOC framework which enables LiteX-based RISC-V SoCs to choose between CLINT and CLIC. Both controllers expose standardized signals for integration: CLINT: timer_interrupt software_interrupt CLIC: clic_interrupt clic_interrupt_id clic_interrupt_priority","title":"Hardware Changes"},{"location":"nav/development/development-guide/#clint-hardware-integration-in-litex","text":"The basic RISC-V interrupt architecture defined in the RISC-V privileged specification, using CSRs (Control and Status Registers) like mie and mip for interrupt management.","title":"CLINT Hardware Integration in Litex"},{"location":"nav/development/development-guide/#summary-of-changes","text":"CLINT Core Module ( litex/soc/cores/clint.py ): Multi-HART support with configurable num_harts parameter. Separate timer and software interrupt outputs per HART. 64-bit MTIME counter with auto-increment. Per-HART 64-bit MTIMECMP registers. Per-HART MSIP bits for software interrupts. CSR-based register interface with proper naming. Helper method add_to_soc() for easy integration. Minerva CPU Updates ( litex/soc/cores/cpu/minerva/core.py ): Added CLINT interrupt support to Minerva CPU. Ibex CPU Updates ( litex/soc/cores/cpu/ibex/core.py ): Added CLINT interrupt support to Ibex CPU. VexRiscv CPU Updates ( litex/soc/cores/cpu/vexriscv/core.py ): Added CLINT interrupt support to VexRiscv CPU. SoCCore Support ( litex/soc/integration/soc_core.py ): Added CLINT parameters ( --with-clint ). CLINT instantiation for compatible CPUs. Software Support ( .../irq.h , .../clint.h ): Generic Interrupt Service Routines (ISRs) to handle timer and software interrupts. C functions for CLINT configuration and control provided via clint.h . The implementation of the CLINT design is compliant with both the older SiFive CLINT design and the newer RISC-V ACLINT specification .","title":"Summary of Changes:"},{"location":"nav/development/development-guide/#clic-hardware-integration-in-litex","text":"An advanced interrupt controller that provides enhanced features for real-time applications.","title":"CLIC Hardware Integration in Litex"},{"location":"nav/development/development-guide/#summary-of-changes_1","text":"CLIC Core Module ( litex/soc/cores/clic.py ): Implements RISC-V CLIC specification features. Supports up to 4096 interrupts with configurable priority. Edge/level trigger configuration per interrupt. Hardware priority arbitration and interrupt preemption. CSR interface for configuration registers. Minerva CPU Updates ( litex/soc/cores/cpu/minerva/core.py ): Added CLIC interrupt signals (interrupt request, ID, priority). Automatic CLIC instantiation when CPU has CLIC support. Defined CLIC memory address region. Ibex CPU Updates ( litex/soc/cores/cpu/ibex/core.py ): Added CLIC interrupt signals (interrupt request, ID, priority). Automatic CLIC instantiation when CPU has CLIC support. Defined CLIC memory address region. VexRiscv CPU Updates ( litex/soc/cores/cpu/vexriscv/core.py ): Added CLIC interrupt support to VexRiscv CPU. SoC Integration ( litex/soc/integration/soc.py ): Added add_clic() method for easy CLIC integration. Automatic connection of interrupt sources to CLIC inputs. CSR mapping for CLIC configuration. SoCCore Support ( litex/soc/integration/soc_core.py ): Added CLIC parameters ( --with-clic , --clic-num-interrupts , --clic-ipriolen ). CLIC instantiation for compatible CPUs.","title":"Summary of Changes:"},{"location":"nav/development/development-guide/#software-changes","text":"The CLINT/CLIC Interrupt Controller Implementations if enabled in LiteX-based RISC-V SoCs can be accessed via software.","title":"Software Changes"},{"location":"nav/development/development-guide/#clint-software-integration-in-litex","text":"Software Driver ( .../irq.h , .../clint.h ): Provides generic Interrupt Service Routines (ISRs) for handling timer and software interrupts. Includes C functions for configuring and controlling the CLINT via clint.h . Software Demo Application ( clint_demo.c ): Demonstrates triggering and handling software interrupts using the CLINT. Offers a practical example of utilizing the CLINT C API.","title":"CLINT Software Integration in Litex"},{"location":"nav/development/development-guide/#clic-software-integration-in-litex","text":"Software Driver ( .../irq.h , .../clic.h ): Implements generic ISRs for managing prioritized external interrupts. Supplies C functions for configuring and controlling the CLIC via clic.h . Features interrupt enable/disable, priority configuration, and attribute settings. Supports direct CSR access for the first 16 interrupts. Software Demo Application ( clic_demo.c ): Highlights advanced interrupt capabilities of the CLIC. Includes tests for priority-based preemption, interrupt thresholding, and edge/level-triggered modes. Serves as a detailed example of using the CLIC C API effectively.","title":"CLIC Software Integration in Litex"},{"location":"nav/development/development-guide/#linux-implementation","text":"VexRiscv-SMP Litex SOC which is capable of booting Linux already supports CLINT Interrupt Controller. CLIC implementation has been added to VexRiscv-SMP Litex SOC with below Pull-Request: Adding CLIC support to VexRiscv SMP CPU . Adding CLIC support to Linux-on-LiteX SoC . Adding CLIC support to RISCV Opensbi","title":"Linux Implementation"},{"location":"nav/development/development-guide/#hardware-changes_1","text":"","title":"Hardware Changes"},{"location":"nav/development/development-guide/#summary-of-changes_2","text":"","title":"Summary of Changes:"},{"location":"nav/development/development-guide/#vexriscv-smp-cpu-core","text":"VexRiscv/src/main/scala/vexriscv/demo/smp/VexRiscvSmpLitexCluster.scala Added command-line option --with-clic Modified CSR configuration to use CsrPluginConfig.withClic() when enabled","title":"VexRiscv SMP CPU Core"},{"location":"nav/development/development-guide/#litex-soc-with-vexriscv-smp-cpu-core","text":"litex/litex/soc/cores/cpu/vexriscv_smp/core.py Added CLIC support detection and signal creation Added --with-clic command-line argument to pass it to Verilog generator","title":"Litex SOC with VexRiscv SMP CPU Core"},{"location":"nav/development/development-guide/#linux-on-litex-integration","text":"linux-on-litex-vexriscv/sim.py Sets VexRiscvSMP.with_clic = True before SoC creation Adds CLIC controller to simulated SoC when --with-clic is specified linux-on-litex-vexriscv/make.py Similar CLIC integration for hardware builds Validates CPU has CLIC support before adding controller","title":"Linux-on-LiteX Integration"},{"location":"nav/development/development-guide/#software-changes_1","text":"","title":"Software Changes"},{"location":"nav/development/development-guide/#summary-of-changes_3","text":"","title":"Summary of Changes:"},{"location":"nav/development/development-guide/#clic-software-integration-in-opensbi","text":"opensbi/platform/litex/vexriscv/platform.c Added CLIC support detection and handling interrupts","title":"CLIC Software Integration in Opensbi"},{"location":"nav/development/development-guide/#clic-node-generation-in-device-tree","text":"litex/litex/soc/cores/cpu/vexriscv_smp/core.py Added clic_base = 0xf200_0000 Updated mem_map property to include CLIC when enabled litex/litex/soc/integration/soc.py Modified add_clic() to add CLIC memory region to bus Added self.bus.add_region(\"clic\", SoCRegion(...)) for proper device tree generation litex/litex/soc/integration/soc_core.py Updated CLIC initialization to use CPU's CLIC base address from memory map litex/litex/tools/litex_json2dts_linux.py Added complete CLIC device tree generation support Updated interrupt parent references to use CLIC when available Kernel Driver - PENDING","title":"CLIC Node Generation in Device Tree"},{"location":"nav/development/development-guide/#testing","text":"","title":"Testing"},{"location":"nav/development/development-guide/#summary-of-changes_4","text":"","title":"Summary of Changes:"},{"location":"nav/development/development-guide/#litex-generated-clic-dut-test-framework","text":"A complete cocotb test framework for CLIC using LiteX-generated DUT has been created : CLIC Cocotb Test Framework","title":"LiteX-Generated CLIC DUT Test Framework"},{"location":"nav/development/development-guide/#components-created","text":"","title":"Components Created"},{"location":"nav/development/development-guide/#1-litex-dut-generator-wrappersgenerate_clicpy","text":"Purpose : Generates CLIC hardware using LiteX framework Features : Full CLIC implementation from litex.soc.cores.clic Wishbone slave interface for CSR access Configurable number of interrupts (default: 16) Proper CSR memory mapping at 0xf0c00000 Complete interrupt signaling interface","title":"1. LiteX DUT Generator (wrappers/generate_clic.py)"},{"location":"nav/development/development-guide/#2-generated-files","text":"build_clic/gateware/dut.v : Complete CLIC Verilog implementation (~106KB) csr_clic.csv : CSR register map with all CLIC registers tb_clic_litex.v : Testbench wrapper for cocotb compatibility","title":"2. Generated Files"},{"location":"nav/development/development-guide/#3-test-infrastructure","text":"test_clic_litex.py : Main test suite with 7 test functions tests/test_clic_litex_basic.py : Basic functionality tests tests/test_clic_litex_priority.py : Priority arbitration tests tests/test_clic_litex_csr.py : CSR access tests tests/test_clic_litex_performance.py : Performance measurement tests","title":"3. Test Infrastructure"},{"location":"nav/development/development-guide/#how-it-works","text":"","title":"How It Works"},{"location":"nav/development/development-guide/#litex-generation-process","text":"# The generate_clic.py script: 1. Creates a CLICTestSoC with CLIC module 2. Maps CSR registers at 0xf0c00000 3. Connects wishbone interface 4. Wires CLIC interrupt signals 5. Generates synthesizable Verilog","title":"LiteX Generation Process"},{"location":"nav/development/development-guide/#test-flow","text":"1. Generate DUT: python3 wrappers/generate_clic.py 2. Compile: pytest test_clic_litex.py::test_compile_litex_clic 3. Test: pytest test_clic_litex.py::test_litex_clic_basic","title":"Test Flow"},{"location":"nav/development/development-guide/#test-coverage","text":"","title":"Test Coverage"},{"location":"nav/development/development-guide/#functional-tests","text":"\u2705 Compilation : Successful \u2705 Basic Test : Interrupt generation and acknowledgment \u2705 Individual Interrupts : Parameterized testing (0-3) \u2705 CSR Access : Wishbone register read/write \u2705 Priority Arbitration : Multi-interrupt priority handling","title":"Functional Tests"},{"location":"nav/development/development-guide/#performance-tests","text":"\u2705 Interrupt Latency : Time required to handle interrupts \u2705 Interrupt Throughput : Interrupts per second measurement \u2705 Priority Switch Time : Time required to switch between interrupts \u2705 Acknowledgment Time : Time required to acknowledge an interrupt","title":"Performance Tests"},{"location":"nav/development/development-guide/#clic-integration-with-full-system","text":"LiteX-generated CLIC can be integrated into a complete SoC: from litex.soc.cores.clic import CLIC class MySoC(SoCCore): def __init__(self): # Add CLIC to your SoC self.submodules.clic = CLIC(num_interrupts=64) self.clic.add_csr_interface(self) # Connect to CPU self.cpu.clicInterrupt.eq(self.clic.clicInterrupt[0]) # ... other connections","title":"CLIC Integration with Full System"},{"location":"nav/styles/colors/","text":"Colors Introduction By integrating RISC-V Advanced Interrupt Architecture (AIA) support into the LiteX SoC framework, we aim to enhance LiteX with modern interrupt handling capabilities that support message-signaled interrupts (MSIs), virtualization, and improved scalability for multi-core systems. Background The RISC-V Advanced Interrupt Architecture (AIA) represents the next generation of interrupt handling for RISC-V systems, offering significant advantages over traditional interrupt controllers: Message-Signaled Interrupts (MSIs): Direct support for PCIe and other modern peripheral standards Virtualization Support: Hardware-assisted interrupt virtualization for guest VMs Scalability: Support for up to 16,384 harts with thousands of interrupt sources Flexible Priority Management: Software-configurable interrupt priorities across all interrupt types Improved Latency: Hardware acceleration for interrupt delivery and handling","title":"Colors"},{"location":"nav/styles/colors/#colors","text":"","title":"Colors"},{"location":"nav/styles/colors/#introduction","text":"By integrating RISC-V Advanced Interrupt Architecture (AIA) support into the LiteX SoC framework, we aim to enhance LiteX with modern interrupt handling capabilities that support message-signaled interrupts (MSIs), virtualization, and improved scalability for multi-core systems.","title":"Introduction"},{"location":"nav/styles/colors/#background","text":"The RISC-V Advanced Interrupt Architecture (AIA) represents the next generation of interrupt handling for RISC-V systems, offering significant advantages over traditional interrupt controllers: Message-Signaled Interrupts (MSIs): Direct support for PCIe and other modern peripheral standards Virtualization Support: Hardware-assisted interrupt virtualization for guest VMs Scalability: Support for up to 16,384 harts with thousands of interrupt sources Flexible Priority Management: Software-configurable interrupt priorities across all interrupt types Improved Latency: Hardware acceleration for interrupt delivery and handling","title":"Background"}]}